 ë„í˜• ë¬¸ì œ ìë™ ìƒì„± ê·œì¹™(ì•Œê³ ë¦¬ì¦˜ ì„¤ê³„)

ì‚¬ì´íŠ¸ìš© ë‚œì´ë„ ì„ íƒ UI ì„¤ê³„ + ì˜ˆì‹œ ì½”ë“œ

1ï¸âƒ£ ë„í˜• ë¬¸ì œ ìë™ ìƒì„± ê·œì¹™ (ì•Œê³ ë¦¬ì¦˜í™”)
0. ê¸°ë³¸ ê°œë… ì„¤ê³„

ë¨¼ì € â€œë„í˜•â€ì„ ì½”ë“œì—ì„œ ì–´ë–»ê²Œ í‘œí˜„í• ì§€ ì¡ì•„ì•¼ í•©ë‹ˆë‹¤.

type ShapeType = 'circle' | 'triangle' | 'square' | 'pentagon' | 'hexagon';
type FillType  = 'empty' | 'half' | 'quarter' | 'full';
type ColorType = 'black' | 'gray' | 'white';
type SizeType  = 'small' | 'medium' | 'large';

interface Shape {
  type: ShapeType;
  fill: FillType;
  color: ColorType;
  rotation: number;   // 0, 90, 180, 270
  size: SizeType;
  dots?: number;      // ì•ˆì— ìˆëŠ” ì  ê°œìˆ˜ (ì˜µì…˜)
}

interface Puzzle {
  difficulty: 'easy' | 'medium' | 'hard';
  sequence: Shape[];      // ë¬¸ì œì— ë³´ì—¬ì¤„ ë„í˜•ë“¤
  options: Shape[];       // ë³´ê¸°ë“¤
  correctIndex: number;   // ì •ë‹µ ì¸ë±ìŠ¤
  ruleDescription?: string; // (ê´€ë¦¬ììš© ì„¤ëª…)
}


ì´ë ‡ê²Œ ì •ë¦¬í•´ë‘ë©´,
**â€œê·œì¹™ = ê° ë‹¨ê³„ì—ì„œ ì–´ë–»ê²Œ ì†ì„±ì„ ë°”ê¾¸ëŠ” í•¨ìˆ˜ì¸ê°€â€**ë¡œ ìƒê°í•˜ë©´ ë©ë‹ˆë‹¤.

1. ì´ˆê¸‰ ì•Œê³ ë¦¬ì¦˜ (ë‹¨ì¼ ê·œì¹™)

í•˜ë‚˜ì˜ ì†ì„±ë§Œ ë³€í™”ì‹œí‚¤ëŠ” íƒ€ì…ì…ë‹ˆë‹¤.

1-1. ê°œìˆ˜ ì¦ê°€ ìˆ˜ì—´ (â— ê°œìˆ˜)

ê·œì¹™: në²ˆì§¸ ë„í˜•ì˜ ì  ê°œìˆ˜ = base + step * n

ì˜ˆ: base=1, step=1 â†’ 1,2,3,4,5â€¦

function generateEasyCountPuzzle(): Puzzle {
  const length = 4; // ë³´ì—¬ì¤„ ë„í˜• ê°œìˆ˜
  const base = 1;
  const step = 1;

  const sequence: Shape[] = [];
  for (let i = 0; i < length; i++) {
    sequence.push({
      type: 'circle',
      fill: 'empty',
      color: 'black',
      rotation: 0,
      size: 'medium',
      dots: base + step * i
    });
  }

  const correctDots = base + step * length;

  // ë³´ê¸° ìƒì„± (ì •ë‹µ + ê·¼ì²˜ ê°’ë“¤)
  const optionsDots = new Set<number>([correctDots]);
  while (optionsDots.size < 4) {
    const delta = Math.floor(Math.random() * 3) + 1; // 1~3
    optionsDots.add(correctDots + (Math.random() < 0.5 ? delta : -delta));
  }
  const dotsArray = Array.from(optionsDots);
  const correctIndex = dotsArray.indexOf(correctDots);

  const options: Shape[] = dotsArray.map(d => ({
    type: 'circle',
    fill: 'empty',
    color: 'black',
    rotation: 0,
    size: 'medium',
    dots: d
  }));

  return {
    difficulty: 'easy',
    sequence,
    options,
    correctIndex,
    ruleDescription: 'ì  ê°œìˆ˜ê°€ 1ì”© ì¦ê°€í•˜ëŠ” ê·œì¹™'
  };
}

1-2. ë³€ ê°œìˆ˜ ìˆ˜ì—´ (ì›â†’ì‚¼â†’ì‚¬â†’ì˜¤â†’ìœ¡ê°í˜•)

ê·œì¹™: ë„í˜• type ë°°ì—´ì„ ìˆœí™˜

const polygonOrder: ShapeType[] = ['circle','triangle','square','pentagon','hexagon'];

function nextPolygon(current: ShapeType): ShapeType {
  const idx = polygonOrder.indexOf(current);
  return polygonOrder[(idx + 1) % polygonOrder.length];
}


ë¬¸ì œ ìƒì„±: ì‹œì‘ ë„í˜• ëœë¤, 4~5ë‹¨ê³„ ìˆ˜ì—´ ìƒì„±, ë‹¤ìŒ ë„í˜•ì„ ë³´ê¸°ì—ì„œ ì°¾ê²Œ.

1-3. ì±„ì›€ ì •ë„ ìˆœí™˜ (ë¹ˆâ†’Â¼â†’Â½â†’ì „ì²´â†’ë¹ˆâ€¦)

ê·œì¹™: fillOrder ë°°ì—´ ìˆœí™˜

const fillOrder: FillType[] = ['empty','quarter','half','full'];

function nextFill(current: FillType): FillType {
  const idx = fillOrder.indexOf(current);
  return fillOrder[(idx + 1) % fillOrder.length];
}

2. ì¤‘ê¸‰ ì•Œê³ ë¦¬ì¦˜ (2ê°œ ì†ì„± ë™ì‹œ ë³€í™”)

ë‘ ê°€ì§€ ì†ì„±ì„ ë™ì‹œì— ê·œì¹™ì ìœ¼ë¡œ ë°”ê¾¸ëŠ” ìœ í˜•ì…ë‹ˆë‹¤.

2-1. ëª¨ì–‘ ìˆœí™˜ + ì  ê°œìˆ˜ ì¦ê°€

ëª¨ì–‘: circle â†’ triangle â†’ square â†’ circle â†’ â€¦

ì : 1,2,3,4,5,6 â€¦ ì¦ê°€

const typeOrder: ShapeType[] = ['circle','triangle','square'];

function generateMediumShapeDotsPuzzle(): Puzzle {
  const length = 5;
  const sequence: Shape[] = [];
  let dots = 1;

  for (let i=0; i<length; i++) {
    sequence.push({
      type: typeOrder[i % typeOrder.length],
      fill: 'empty',
      color: 'black',
      rotation: 0,
      size: 'medium',
      dots
    });
    dots++;
  }

  const correctShape: Shape = {
    type: typeOrder[length % typeOrder.length],
    fill: 'empty',
    color: 'black',
    rotation: 0,
    size: 'medium',
    dots
  };

  // ë³´ê¸° ìƒì„±: ëª¨ì–‘/ì  ìˆ«ìë¥¼ ì‚´ì§ í‹€ë¦¬ê²Œ ì„ì–´ì„œ 4ê°œ
  const options: Shape[] = [];
  const correctIndex = Math.floor(Math.random()*4);

  for (let i=0; i<4; i++) {
    if (i === correctIndex) {
      options.push(correctShape);
    } else {
      options.push({
        ...correctShape,
        type: (Math.random() < 0.5 ? correctShape.type : typeOrder[(typeOrder.indexOf(correctShape.type)+1)%typeOrder.length]),
        dots: correctShape.dots! + (Math.random()<0.5 ? -1 : 1)
      });
    }
  }

  return {
    difficulty: 'medium',
    sequence,
    options,
    correctIndex,
    ruleDescription: 'ëª¨ì–‘ ìˆœí™˜ + ì  ê°œìˆ˜ 1ì”© ì¦ê°€'
  };
}

2-2. íšŒì „ + ìƒ‰ìƒ êµëŒ€

íšŒì „: 0 â†’ 90 â†’ 180 â†’ 270 â†’ 0 â€¦

ìƒ‰ìƒ: ê²€ì • â†” í°ìƒ‰ êµëŒ€

ê·œì¹™ í•¨ìˆ˜ë§Œ ìˆìœ¼ë©´ ì‘ìš© ì‰¬ì›€:

function nextRotation(r: number): number {
  return (r + 90) % 360;
}

function toggleColor(c: ColorType): ColorType {
  return c === 'black' ? 'white' : 'black';
}

3. ê³ ê¸‰ ì•Œê³ ë¦¬ì¦˜ (ê·¸ë¦¬ë“œ + í•©ì„± ê·œì¹™)

3Ã—3 í–‰ì—´ + â€œí–‰/ì—´ë³„ ê³„ì‚° ê·œì¹™â€ ê°™ì€ ë©˜ì‚¬ ëŠë‚Œ ë¬¸ì œ.

3-1. 3Ã—3 ê·¸ë¦¬ë“œ â€“ â€œì„¸ ë²ˆì§¸ ì¹¸ = ì• ë‘ ì¹¸ì˜ í•©â€

ì˜ˆ:

1í–‰: ì  1, 2, 3

2í–‰: ì  2, 3, 5

3í–‰: ì  3, 4, ? â†’ ì •ë‹µ 7

interface GridPuzzle extends Puzzle {
  grid: Shape[][]; // 3x3
  missingCell: {row: number, col: number};
}

function generateHardGridSumPuzzle(): GridPuzzle {
  const rows = 3;
  const cols = 3;
  const grid: Shape[][] = [];

  // ì„ì˜ base ê°’ ì„¤ì •
  const baseRow1Col1 = 1;
  const baseDiff = 1;

  for (let r=0; r<rows; r++) {
    const row: Shape[] = [];
    const a = baseRow1Col1 + r * baseDiff;
    const b = a + 1;
    const c = a + b; // í•©

    [a,b,c].forEach(dots => {
      row.push({
        type: 'circle',
        fill: 'empty',
        color: 'black',
        rotation: 0,
        size: 'medium',
        dots
      });
    });
    grid.push(row);
  }

  // ë§ˆì§€ë§‰ ì¹¸ì„ ë¹ˆì¹¸ìœ¼ë¡œ
  const missingRow = 2, missingCol = 2;
  const correctDots = grid[missingRow][missingCol].dots!;
  grid[missingRow][missingCol].dots = undefined; // í™”ë©´ìƒ ë¹ˆì¹¸ ì²˜ë¦¬

  // ë³´ê¸°
  const optionsDots = new Set<number>([correctDots]);
  while (optionsDots.size < 4) {
    const delta = Math.floor(Math.random()*3)+1;
    optionsDots.add(correctDots + (Math.random()<0.5 ? delta : -delta));
  }
  const dotsArr = Array.from(optionsDots);
  const correctIndex = dotsArr.indexOf(correctDots);

  const options: Shape[] = dotsArr.map(d => ({
    type: 'circle',
    fill: 'empty',
    color: 'black',
    rotation: 0,
    size: 'medium',
    dots: d
  }));

  return {
    difficulty: 'hard',
    sequence: [], // grid ê¸°ë°˜ì´ë¼ ë¹„ì›Œë‘¬ë„ ë¨
    options,
    correctIndex,
    ruleDescription: 'ê° í–‰ì—ì„œ 3ë²ˆì§¸ ì¹¸ = 1ë²ˆì§¸ + 2ë²ˆì§¸',
    grid,
    missingCell: {row: missingRow, col: missingCol}
  };
}

3-2. ë„í˜• ì—°ì‚° ê·œì¹™ (ë³€ ê°œìˆ˜ í•©)

ê·œì¹™:

ì‚¼ê°í˜•(3) + ì‚¬ê°í˜•(4) = ì˜¤ê°í˜•(5)

typeToSides(type) ì •ì˜ í›„,

í•© = sides(a) + sides(b) - something ê°™ì€ í˜•íƒœë¡œë„ í™•ì¥ ê°€ëŠ¥.

4. ë‚œì´ë„ë³„ ìë™ ìƒì„± ì „ëµ ìš”ì•½

easy:

ë‹¨ì¼ ì†ì„±(ê°œìˆ˜, í¬ê¸°, íšŒì „, ì±„ì›€, ìƒ‰ìƒ)ë§Œ ê·œì¹™

ì‹œê°ì ìœ¼ë¡œ ë°”ë¡œ ëŠê»´ì§€ëŠ” íŒ¨í„´ ìœ„ì£¼

medium:

2ê°œì˜ ì†ì„±ì„ ë™ì‹œì— ë°”ê¿ˆ (ëª¨ì–‘ + ì , íšŒì „ + ìƒ‰ìƒ ë“±)

í•œ ë²ˆì— ê·œì¹™ì´ ì•ˆ ë³´ì´ì§€ë§Œ, ì¡°ê¸ˆë§Œ ìƒê°í•˜ë©´ ë³´ì´ëŠ” ì •ë„

hard:

2D ê·¸ë¦¬ë“œ(3Ã—3 / 2Ã—3)

í–‰/ì—´ ê·œì¹™, í•©/ì°¨, ë‹¤ë‹¨ê³„ ê·œì¹™(â€œìœ„ + ì™¼ìª½ = í˜„ì¬â€)

ë„í˜• ì—°ì‚° ê°œë…(ë³€ ê°œìˆ˜, ì  ê°œìˆ˜, ìƒ‰/íšŒì „ ì„ì„)

2ï¸âƒ£ ì‚¬ì´íŠ¸ìš© ë‚œì´ë„ ì„ íƒ UI ì„¤ê³„

ì´ì œ ì´ ìë™ ìƒì„± í•¨ìˆ˜ë“¤ì„ UIì—ì„œ ì–´ë–»ê²Œ ê³ ë¥´ê²Œ í• ì§€ì…ë‹ˆë‹¤.

1. UX í”Œë¡œìš°

ë©”ì¸ í™”ë©´ì—ì„œ ë‚œì´ë„ ì„ íƒ:

[ì´ˆê¸‰] [ì¤‘ê¸‰] [ê³ ê¸‰] ë²„íŠ¼/ì¹´ë“œ

ë‚œì´ë„ ì„ íƒí•˜ë©´:

í•´ë‹¹ ë‚œì´ë„ìš© ë¬¸ì œë¥¼ generateXXXPuzzle() í•¨ìˆ˜ë¡œ ìƒì„±

ë„í˜• ë Œë”ë§:

sequence / grid / options ì„ Canvas, SVG, div+CSSë¡œ ê·¸ë¦¼

ìœ ì €ê°€ ë³´ê¸° í´ë¦­ â†’ ì •ë‹µ/ì˜¤ë‹µ í”¼ë“œë°± â†’ ë‹¤ìŒ ë¬¸ì œ ë²„íŠ¼

2. ë‚œì´ë„ ì„ íƒ UI ë ˆì´ì•„ì›ƒ(ê°œë…)
--------------------------------------------------
|   ë¡œê³  / ì‚¬ì´íŠ¸ ì´ë¦„                            |
--------------------------------------------------
|   ì˜¤ëŠ˜ì˜ ë„í˜• IQ í…ŒìŠ¤íŠ¸                         |
|   ë‚œì´ë„ë¥¼ ì„ íƒí•˜ì„¸ìš”                           |
--------------------------------------------------
|  [ ğŸŸ¢ ì´ˆê¸‰ ]  [ ğŸŸ¡ ì¤‘ê¸‰ ]  [ ğŸ”´ ê³ ê¸‰ ]           |
|   (ê°„ë‹¨ ì„¤ëª… / ì˜ˆìƒ ì‹œê°„ / ì¶”ì²œ ëŒ€ìƒ)           |
--------------------------------------------------
|   ì„ íƒ í›„ ì•„ë˜ì— ë¬¸ì œ ì˜ì—­ í‘œì‹œ                 |
--------------------------------------------------
|   [ë„í˜• ë¬¸ì œ í™”ë©´]                              |
--------------------------------------------------

3. HTML/CSS/JS ì˜ˆì‹œ (ê°„ë‹¨ ë²„ì „)
<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>ë„í˜• IQ í…ŒìŠ¤íŠ¸</title>
<style>
body { font-family: system-ui, sans-serif; background:#f5f7fb; margin:0; padding:20px; }
.container { max-width:900px; margin:0 auto; }
.difficulty-row { display:flex; gap:12px; margin-bottom:20px; }
.diff-btn {
  flex:1; padding:16px; border-radius:14px; border:none;
  cursor:pointer; font-size:18px; font-weight:600;
}
.diff-easy { background:#e0ffe4; }
.diff-medium { background:#fff9d6; }
.diff-hard { background:#ffe0e0; }
.card {
  background:#fff; border-radius:16px; padding:24px;
  box-shadow:0 8px 20px rgba(0,0,0,0.08);
}
.options { display:flex; gap:12px; margin-top:20px; flex-wrap:wrap; }
.option {
  flex:1 1 100px; min-width:120px; padding:12px; border-radius:12px;
  border:2px solid #dde1f0; text-align:center; cursor:pointer;
}
.option.correct { border-color:#4caf50; background:#e8f9ec; }
.option.wrong { border-color:#f44336; background:#ffeaea; }
#feedback { margin-top:10px; font-weight:600; }
</style>
</head>
<body>
<div class="container">
  <h1>ë„í˜• IQ í…ŒìŠ¤íŠ¸</h1>
  <p>ë‚œì´ë„ë¥¼ ì„ íƒí•˜ê³  ë¬¸ì œë¥¼ í’€ì–´ë³´ì„¸ìš”.</p>

  <div class="difficulty-row">
    <button class="diff-btn diff-easy" onclick="startQuiz('easy')">ğŸŸ¢ ì´ˆê¸‰</button>
    <button class="diff-btn diff-medium" onclick="startQuiz('medium')">ğŸŸ¡ ì¤‘ê¸‰</button>
    <button class="diff-btn diff-hard" onclick="startQuiz('hard')">ğŸ”´ ê³ ê¸‰</button>
  </div>

  <div id="puzzle-card" class="card" style="display:none;">
    <div id="puzzle-visual">[ë„í˜• í‘œì‹œ ì˜ì—­]</div>
    <div class="options" id="options"></div>
    <div id="feedback"></div>
  </div>
</div>

<script>
// ì—¬ê¸° generateEasy/Medium/HardPuzzleì€ ìœ„ì—ì„œ ì„¤ê³„í•œ ê²ƒë“¤ì´ ë“¤ì–´ê°„ë‹¤ê³  ë³´ë©´ ë©ë‹ˆë‹¤.
// ë°ëª¨ìš©ìœ¼ë¡œ ì•„ì£¼ ë‹¨ìˆœí•œ ë¬¸ìì—´ ê¸°ë°˜ í¼ì¦ì„ ë„£ê² ìŠµë‹ˆë‹¤.

function fakeGeneratePuzzle(level){
  if(level === 'easy'){
    return {
      difficulty:'easy',
      sequence: ['â—','â—â—','â—â—â—','â—â—â—â—'],
      options: ['â—â—','â—â—â—â—â—','â—â—â—','â—â—â—â—â—â—'],
      correctIndex:1
    }
  }
  if(level === 'medium'){
    return {
      difficulty:'medium',
      sequence: ['â—‹(1)','â–²(2)','â– (3)','â—‹(4)','â–²(5)'],
      options: ['â– (5)','â– (6)','â—‹(6)','â–²(6)'],
      correctIndex:1
    }
  }
  return {
    difficulty:'hard',
    sequence: ['1,2 -> 3','2,3 -> 5','3,4 -> ?'],
    options: ['6','7','8','9'],
    correctIndex:1
  }
}

let currentPuzzle = null;

function startQuiz(level){
  currentPuzzle = fakeGeneratePuzzle(level); // ì‹¤ì œë¡œëŠ” generateEasyCountPuzzle() ë“± í˜¸ì¶œ
  document.getElementById('puzzle-card').style.display = 'block';
  renderPuzzle();
}

function renderPuzzle(){
  const vis = document.getElementById('puzzle-visual');
  const opts = document.getElementById('options');
  const fb = document.getElementById('feedback');

  fb.textContent = '';
  // ê°„ë‹¨íˆ sequenceë¥¼ ë¬¸ìì—´ë¡œ ê·¸ëƒ¥ ë³´ì—¬ì£¼ëŠ” ë²„ì „
  vis.innerHTML = `<div>ìˆ˜ì—´: ${currentPuzzle.sequence.join(' â†’ ')} â†’ ?</div>`;

  opts.innerHTML = '';
  currentPuzzle.options.forEach((opt, idx)=>{
    const div = document.createElement('div');
    div.className = 'option';
    div.textContent = opt;
    div.onclick = () => choose(idx, div);
    opts.appendChild(div);
  });
}

function choose(idx, div){
  const fb = document.getElementById('feedback');
  const optionDivs = document.querySelectorAll('.option');
  optionDivs.forEach(o=>o.onclick=null); // í•œ ë²ˆë§Œ ì„ íƒ ê°€ëŠ¥

  if(idx === currentPuzzle.correctIndex){
    div.classList.add('correct');
    fb.textContent = 'ì •ë‹µì…ë‹ˆë‹¤! ğŸ‰';
  } else {
    div.classList.add('wrong');
    optionDivs[currentPuzzle.correctIndex].classList.add('correct');
    fb.textContent = 'ì•„ì‰½ì–´ìš”! ì •ë‹µì´ í‘œì‹œë˜ì—ˆìŠµë‹ˆë‹¤.';
  }
}
</script>
</body>
</html>


ì‹¤ì œ ì„œë¹„ìŠ¤ì—ì„œëŠ” ì—¬ê¸°ì„œ
fakeGeneratePuzzle() â†’ ì•ì—ì„œ ë§Œë“  ë‚œì´ë„ë³„ ìƒì„± í•¨ìˆ˜ë“¤ë¡œ êµì²´í•˜ë©´ ë©ë‹ˆë‹¤.

4. ë‚œì´ë„ ì„ íƒ UX í¬ì¸íŠ¸

ì´ˆê¸‰ ë²„íŠ¼ì— ì„¤ëª…

â€œë„í˜• ê°œìˆ˜/í¬ê¸°ë§Œ ë°”ë€ŒëŠ” ì‰¬ìš´ ë¬¸ì œâ€

ì¤‘ê¸‰ ë²„íŠ¼ì— ì„¤ëª…

â€œë‘ ê°€ì§€ ê·œì¹™(ëª¨ì–‘+ì , íšŒì „+ìƒ‰ìƒ)ì´ ì„ì¸ ë¬¸ì œâ€

ê³ ê¸‰ ë²„íŠ¼ì— ì„¤ëª…

â€œ3Ã—3 ê·¸ë¦¬ë“œ, í•©/ì°¨, ë³µí•© ê·œì¹™ ë¬¸ì œâ€

ê·¸ë¦¬ê³ :

ë¬¸ì œ í’€ê³  ë‚˜ë©´ â€œì´ ë‚œì´ë„ë¡œ ê³„ì† í’€ê¸° / ë‹¤ë¥¸ ë‚œì´ë„ ê°€ê¸°â€ CTA ë²„íŠ¼

â€œê³ ê¸‰ 3ê°œ ì´ìƒ ë§íˆë©´ ìƒìœ„ 10%â€ ê°™ì€ ì¹´í”¼ ë„£ìœ¼ë©´ ëª°ì…ë„â†‘

ì •ë¦¬í•˜ë©´

ì•Œê³ ë¦¬ì¦˜ ìª½:

ë„í˜•ì„ ë°ì´í„° êµ¬ì¡°ë¡œ ì •ì˜í•˜ê³ 

â€œì†ì„±ì„ ì–´ë–»ê²Œ í•œ ë‹¨ê³„ì”© ë°”ê¿€ì§€â€ë¥¼ í•¨ìˆ˜ë¡œ ë§Œë“¤ë©´

ì´ˆê¸‰â€“ì¤‘ê¸‰â€“ê³ ê¸‰ ë¬¸ì œë¥¼ ë¬´í•œíˆ ìë™ ìƒì„± ê°€ëŠ¥

UI ìª½:

ë‚œì´ë„ ì„ íƒ â†’ ë‚œì´ë„ë³„ ìƒì„± í•¨ìˆ˜ í˜¸ì¶œ

ë¬¸ì œ ë Œë” â†’ ë³´ê¸° í´ë¦­ â†’ í”¼ë“œë°±

ì´ êµ¬ì¡°ë§Œ ì¡ìœ¼ë©´ ë‚˜ì¤‘ì— ë¬¸ì œ íƒ€ì…ì„ ê³„ì† ì¶”ê°€í•´ë„ í™•ì¥ ì‰¬ì›€